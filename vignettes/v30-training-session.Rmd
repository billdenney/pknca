---
title: "PKNCA Training Sessions"
author: "William Denney"
date: "18 October 2023"
output:
  ioslides_presentation:
    widescreen: true
vignette: >
  %\VignetteIndexEntry{PKNCA Training Sessions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
requireNamespace("pmxTools")
library(PKNCA)
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
breaks_hours <- function(n=5, Q=c(1, 6, 4, 12, 2, 24, 168), ...) {
  n_default <- n
  Q_default <- Q
  function(x, n = n_default, Q=Q_default) {
    x <- x[is.finite(x)]
    if (length(x) == 0) {
      return(numeric())
    }
    rng <- range(x)
    labeling::extended(rng[1], rng[2], m=n, Q=Q, ...)
  }
}

scale_x_hours <- function(..., breaks=breaks_hours()) {
  ggplot2::scale_x_continuous(..., breaks=breaks)
}
```

<style>
.forceBreak { -webkit-column-break-after: always; break-after: column; }

<!-- from https://stackoverflow.com/questions/1909648/stacking-divs-on-top-of-each-other -->
.container {
  width: 300px;
  height: 300px;
  margin: 0 auto;
  background-color: yellow;
  /* important part */
  display: grid;
  place-items: center;
  grid-template-areas: "inner-div";
}

.inner {
  /* important part */
  grid-area: inner-div;
}

.bigStrikethroughOuter {
  <!-- text-decoration: line-through; -->
  font-size: 8em;
  text-align: center;
  color: red;
  background: 
  linear-gradient(to top left,
    transparent 0%,
    transparent calc(50% - 0.05em),
    red calc(50% - 0.05em),
    red 50%,
    red calc(50% + 0.05em),
    transparent calc(50% + 0.05em),
    transparent 100%),
  linear-gradient(to top right,
    transparent 0%,
    transparent calc(50% - 0.05em),
    red calc(50% - 0.05em),
    red 50%,
    red calc(50% + 0.05em),
    transparent calc(50% + 0.05em),
    transparent 100%);
}

.bigStrikethroughInner {
  color: blue;
  font-size: 8em;
}

.autoImageWidth {
  width: auto !important; /*override the width below*/
  max-width: 100%;
  float: left;
  clear: both;
  text-align: center;
}

<!-- imessages -->

.imessage {
  font-family: helvetica;
  display: flex ;
  flex-direction: column;
  align-items: center;
}

.chat {
  width: 300px;
  border: solid 1px #EEE;
  display: flex;
  flex-direction: column;
  padding: 10px;
}

.messages {
  margin-top: 30px;
  display: flex;
  flex-direction: column;
}

.message {
  border-radius: 20px;
  padding: 8px 15px;
  margin-top: 5px;
  margin-bottom: 5px;
  display: inline-block;
}

.yours {
  align-items: flex-start;
}

.yours .message {
  margin-right: 25%;
  background-color: #eee;
  position: relative;
}

.yours .message.last:before {
  content: "";
  position: absolute;
  z-index: 0;
  bottom: 0;
  left: -7px;
  height: 20px;
  width: 20px;
  background: #eee;
  border-bottom-right-radius: 15px;
}
.yours .message.last:after {
  content: "";
  position: absolute;
  z-index: 1;
  bottom: 0;
  left: -10px;
  width: 10px;
  height: 20px;
  background: white;
  border-bottom-right-radius: 10px;
}

.mine {
  align-items: flex-end;
}

.mine .message {
  color: white;
  margin-left: 25%;
  background: linear-gradient(to bottom, #00D0EA 0%, #0085D1 100%);
  background-attachment: fixed;
  position: relative;
}

.mine .message.last:before {
  content: "";
  position: absolute;
  z-index: 0;
  bottom: 0;
  right: -8px;
  height: 20px;
  width: 20px;
  background: linear-gradient(to bottom, #00D0EA 0%, #0085D1 100%);
  background-attachment: fixed;
  border-bottom-left-radius: 15px;
}

.mine .message.last:after {
  content: "";
  position: absolute;
  z-index: 1;
  bottom: 0;
  right: -10px;
  width: 10px;
  height: 20px;
  background: white;
  border-bottom-left-radius: 10px;
}

</style>

# Introduction to PKNCA and Basics of Its Use

Creation of these materials were partially supported by funding from the Metrum Research Group.

## Introduction to PKNCA {.build .smaller}

PKNCA is a tool for calculating noncompartmental analysis (NCA) results for pharmacokinetic (PK) data.

... but, you already knew that or you wouldn't be here.

PKNCA has several foci:

* be regulatory-ready
    * it has approximately 100% test coverage.
* be reproducible
    * it has a focus on being scriptable.
* get the right answer or none at all
    * it will try to know what you want,
    * but all decisions can be overridden, and
    * if there is a question that may cause an error or an unanticipated result, either no result will output or an error will be raised.

## Enjoy! {.build}

I hope that you have a whale of a good time during this training.

![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)

(Foreshadowing...)

## Some NCA Definitions

* **C~max~**: The maximum observed concentration
* **T~max~**: The time of the maximum observed concentration
* **t~last~**: The time of the last concentration above the limit of quantification
* **AUC**: Area under the concentration-time curve.  Some important AUC variants are:
    * **AUC~last~**: AUC from time zero to t~last~
    * **AUC~int~**: AUC from time zero to the end of an interval of time, often extrapolated or interpolated (e.g. AUC~0-24hr~)
    * **AUC~&infin;~**: AUC from time zero to t~last~ then extrapolated from t~last~ to time infinity using the half life

# Dataset Basics

## NCA Data are Not Tidy ***as a Single Dataset***

"Tidy datasets... have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table." - Hadley Wickham (https://doi.org/10.18637/jss.v059.i10)

CDISC has NCA tidied, and PKNCA follows that model:

* concentration-time is a dataset (PC domain; `PKNCAconc()` object)
* dose-time is a dataset (EX/EC domains; `PKNCAdose()` object)
* NCA results are a dataset (PP domain; `pk.nca()` output)

## Dataset Basics: Minimum data

PKNCA requires at least the concentration, time, and what you want to calculate.

```{r fig.width=6, fig.height=4}
conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
ggplot(conc, aes(x=Time, y=conc)) +
  geom_line() +
  scale_x_hours()
```

## Dataset Basics: What columns are needed?

Column names are provided by the input to `PKNCAconc()` and `PKNCAdose()`; they are not hard-coded.

Columns that can be used include:

* `PKNCAconc()`: concentration, time, groups; data exclusions; half-life inclusion and exclusion
* `PKNCAdose()`: dose, time, groups; route, rate/duration of infusion; data exclusions
* intervals given to `PKNCAdata()`: groups, start, end, and any NCA parameters to calculate

## Dataset Basics:  Example data

In the following slides, abbreviated data from an example study where two treatments ("A" and "B") are administered to two subjects (1 and 2).

* For PKNCA, the groups will be **Treatment** and **Subject**.
    * PKNCA considers groups in order with the subject identifier as the last group (or the last group before a forward slash, `/`, if `/` is present).
    * When indicated in order (`...|Treatment+Subject`), PKNCA automatically knows to keep **Treatment** and drop **Subject** for summaries (more on that later).

## Dataset Basics:  Example concentration data {.columns-2}

```{r}
conc_data <-
  withr::with_seed(5, {
    data.frame(
      Subject=rep(1:2, each=6),
      Treatment=rep(c("A", "B", "A", "B"), each=3),
      Time=rep(c(0, 2, 8), 4),
      Conc=rep(c(0, 2, 0.5), 4)*exp(rnorm(n=12, sd=0.05))
    )
  })
```

```{r}
pander::pander(conc_data %>% filter(Subject == 1))
```

<p class="forceBreak"></p>

```{r}
pander::pander(conc_data %>% filter(Subject == 2))
```

## Dataset Basics:  Example dosing data

```{r}
dose_data <-
  data.frame(
    Subject=rep(1:2, each=2),
    Treatment=c("A", "B", "A", "B"),
    Time=0,
    Dose=10
  )
```

```{r}
pander::pander(dose_data %>% filter(Subject == 1))
```

<p class="forceBreak"></p>

```{r}
pander::pander(dose_data %>% filter(Subject == 2))
```

## Dataset Basics:  Example interval data

```{r, echo=TRUE}
d_interval_1 <-
  data.frame(
    start=0, end=8,
    cmax=TRUE, tmax=TRUE, auclast=TRUE
  )
```

```{r}
pander::pander(d_interval_1)
```

Groups are not required, if you want the same intervals calculated for each group.

## Hands-on: First NCA calculation with PKNCA

```{r echo=TRUE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(PKNCA)
# Concentration data setup
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
# Setup intervals for calculation
d_intervals <- data.frame(start=0, end=24, cmax=TRUE, tmax=TRUE,
                          auclast=TRUE, aucint.inf.obs=TRUE)
# Combine concentration and dose
o_data <- PKNCAdata(o_conc, intervals=d_intervals)
# Calculate the results (suppressMessages() hides a message that isn't needed now)
o_result <- suppressMessages(pk.nca(o_data))
# summary(o_result)
```

# PKNCA Functions

## What functions are the most used?

* `PKNCAconc()`: define a concentration-time `PKNCAconc` object
    * All information about concentration data are given:  concentration, time
    * Optional information includes: grouping information (usually given), data to exclude, half-life inclusion and exclusion columns
* `PKNCAdose()`: define a dose-time `PKNCAdose` object (optional)
    * dose amount and time are both optional
    * Optional information includes: rate or duration of infusion, data to exclude
* `PKNCAdata()`: combine `PKNCAconc`, optionally `PKNCAdose`, and optionally `intervals` into a `PKNCAdata` object
    * the `PKNCAconc` object must be given; the `PKNCAdose` object is optional; interval definitions are usually given; calculation options may be given
* `pk.nca()`: calculate the NCA parameters from a data object into a `PKNCAresult` object

## How do I do a simple calculation? all steps

We will break this down in subsequent slides.

```{r echo=TRUE}
# Concentration data setup
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
# Dose data setup
d_dose <-
  datasets::Theoph %>%
  filter(Subject %in% 1) %>%
  filter(Time == 0)
o_dose <- PKNCAdose(Dose~Time, data=d_dose)
# Combine concentration and dose
o_data <- PKNCAdata(o_conc, o_dose)
# Calculate the results
o_result <- pk.nca(o_data)
```

## How do I do a simple calculation? Concentration data {.smaller}

```{r echo=TRUE}
# Load your dataset as a data.frame
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
# Take a look at the data
pander::pander(head(d_conc, 2))
# Define the PKNCAconc object indicating the concentration and time columns, the
# dataset, and any other options.
o_conc <- PKNCAconc(conc~Time, data=d_conc)
```

## How do I do a simple calculation? Dose data {.smaller}

```{r echo=TRUE}
# Load your dataset as a data.frame
d_dose <-
  datasets::Theoph %>%
  filter(Subject %in% 1) %>%
  filter(Time == 0)
# Take a look at the data
pander::pander(d_dose)
# Define the PKNCAdose object indicating the dose amount and time columns, the
# dataset, and any other options.
o_dose <- PKNCAdose(Dose~Time, data=d_dose)
```

## How do I do a simple calculation? Calculate results {.smaller}

```{r echo=TRUE}
# Combine the PKNCAconc and PKNCAdose objects.  You can add interval
# specifications and calculation options here.
o_data <- PKNCAdata(o_conc, o_dose)
# Calculate the results
o_result <- pk.nca(o_data)
```

## How do I do a simple calculation?  Get results

To calculate summary statistics, use `summary()`; to extract all individual-level results, use `as.data.frame()`.

The `"caption"` attribute of the summary describes how the summary statistics were calculated for each parameter.  (Hint: `pander::pander()` knows how to use that to put the caption on a table in a report.)

The individual results contain the columns for start time, end time, grouping variables (none in this example), parameter names, values, and if the value should be excluded.

## How do I do a simple calculation?  Get summary results {.smaller}

```{r echo=TRUE}
# Look at summarized results
pander::pander(summary(o_result))
```

## How do I do a simple calculation?  Get individual results {.smaller}

Use `as.data.frame()` to get the individual NCA parameter results.

```{r echo=TRUE}
# Look at individual results
pander::pander(head(
  as.data.frame(o_result),
  n=3
))
```

# PKNCA datasets

## How does PKNCA think about data?

Three types of data are inputs for calculation in PKNCA:

* concentration-time (`PKNCAconc`),
* dose-time (`PKNCAdose`), and
* intervals.

`PKNCAconc` and `PKNCAdose` objects can optionally have groups.  The groups in a `PKNCAdose` object must be the same or fewer than the groups in `PKNCAconc` object (for example, all subjects in a treatment arm may receive the same dose).

## What is an "interval" and how is it different than a "group"? {.columns-2 .smaller}

```{r interval-vs-groups-setup, echo=FALSE}
last_dose_time <- 24
dose_interval <- 8
dose_times <- seq(0, last_dose_time-dose_interval, by=dose_interval)
d_conc_superposition <-
  superposition(
    o_conc,
    dose.times=dose_times,
    tau=last_dose_time,
    check.blq=FALSE,
    n.tau=1
  )
```

A **group** separates one full concentration-time profile for a subject that you may ever want to consider at the same time.  Usually, it groups by study, treatment, analyte, and subject (other groups can be useful depending on the study design).

An **interval** selects a time range within a **group**.

One time can be in zero or more intervals, but only zero or one group.  Intervals can be adjacent (0-12 and 12-24) or overlap (0-12 and 0-24).  In other words, one sample may be used in more than one interval, but one sample will never be used in more than one group.

**Legend:**  The group contains all points on the figure.  Shaded regions indicate intervals.  Arrows indicate points shared between intervals within the group.

<p class="forceBreak"></p>

```{r fig.width=4, fig.height=4}
d_intervals <-
  tibble(
    start=dose_times,
    end=dose_times + dose_interval
  ) %>%
  mutate(
    name=sprintf("Interval %g", row_number()),
    height=max(d_conc_superposition$conc)*1.03,
    width=dose_interval,
    x=(start+end)/2,
    y=height/2
  )
d_interval_arrows <-
  d_conc_superposition %>%
  filter(time != 0 & time %in% dose_times) %>%
  mutate(
    name1=sprintf("Interval %g", row_number()),
    name2=sprintf("Interval %g", row_number() + 1),
  )
ggplot(d_conc_superposition, aes(x=time, y=conc)) +
  geom_tile(
    data=d_intervals,
    aes(x=x, y=y, width=width, height=height, colour=name, fill=name),
    alpha=0.2,
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_segment(
    data=d_interval_arrows,
    aes(x=time - 0.8, xend=time - 0.1, y=conc-2.1, yend=conc - 0.1, colour=name2),
    arrow=arrow(length=unit(0.1, "inches")),
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_segment(
    data=d_interval_arrows,
    aes(x=time + 0.8, xend=time + 0.1, y=conc-2.1, yend=conc - 0.1, colour=name1),
    arrow=arrow(length=unit(0.1, "inches")),
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_line() +
  geom_point() +
  scale_x_hours() +
  labs(
    title=sprintf("Dosing Q%gH", dose_interval)
  )
```

## Common data management requirements before sending data to PKNCA {.smaller}

1. Time must not be missing for `PKNCAconc` (if given to `PKNCAdose`, it must not be missing).
2. Below the limit of quantification (BLQ) concentrations must be set to zero (not `NA`).
3. Imputation of time zero is required for AUC calculation.
4. Especially for actual-time calculations, imputation of the beginning of the interval is usually needed.

Columns must be created for:

* Concentration or dose,
* Time
* Groups
    * usually columns for study, treatment arm, subject;
    * sometimes analyte, formulation, period (needed in case the same subject receives the same treatment arm multiple times)

## Setup your concentration data {.columns-2}

* Concentration data must be numeric

<p class="forceBreak"></p>

<div class="bigStrikethroughOuter">
<div class="bigStrikethroughInner">A</div>
</div>

## Setup your concentration data {.columns-2}

* Concentration data must be numeric
* Time must be numeric and not be missing

<p class="forceBreak"></p>

<div class="bigStrikethroughOuter">
<div class="bigStrikethroughInner">NA</div>
</div>

## Setup your concentration data {.columns-2}

* Concentration data must be numeric
* Time must be numeric and not be missing
* Groups can be anything, setup at the level of the individual

<p class="forceBreak"></p>

<div class="autoImageWidth">
![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)<br />
Group: <span style="color: green;">&#128504;</span> a pod of killer whales
</div>

## Setup your dosing data (if you have it and even if you don't) {.smaller}

Normal dosing data setup: `PKNCAdose(dose~time|actarm+usubjid, data=d_dose)`

* Dose amount must be numeric &mdash; or it can be omitted
    * `PKNCAdose(~time|actarm+usubjid, data=d_dose)`
* Time must be numeric and not be missing &mdash; or it can be omitted
    * `PKNCAdose(dose~.|actarm+usubjid, data=d_dose)`
* Groups can be anything &mdash; may be grouped at a higher level than the individual
    * Useful when all dose amounts and times are the same within an arm: `PKNCAdose(dose~time|actarm, data=d_dose)`
    * Useful dose amount is the same at all times within an arm: `PKNCAdose(dose~.|actarm, data=d_dose)`
    * Useful when times are all the same within an arm but dose may differ: `PKNCAdose(~time|actarm, data=d_dose)`

## Define your intervals

Intervals have columns for:

* `start` and `end` times for the interval,
* groups matching any level of grouping; intervals apply by a merge/join with the groups
* parameters to calculate (`TRUE` means to calculate it; `FALSE` means don't).  The full list of available parameters is in the [selection of calculation intervals vignette](http://humanpred.github.io/pknca/articles/Selection-of-Calculation-Intervals.html#parameters-available-for-calculation-in-an-interval-1).
    * You only have to specify the parameter you want, not all parameters.

## Define your intervals: example

* For time 0 to 24, calculate AUClast
* For time 0 to infinity, calculate cmax, tmax, half.life, and aucinf.obs

```{r}
PKNCA.options("single.dose.aucs") %>%
  select(c(all_of(c("start", "end")), where(~is.logical(.x) && any(.x)))) %>%
  pander::pander()
```

# Calculations above the hood

## Prepare your data for calculation

```{r echo=TRUE}
d_conc <-
  datasets::Theoph %>%
  mutate(
    Treatment=
      case_when(
        Dose <= median(Dose)~"Low dose",
        TRUE~"High dose"
      )
  )
# The study was single-dose
d_dose <-
  d_conc %>%
  select(Treatment, Subject, Dose) %>%
  unique() %>%
  mutate(dose_time=0)
```

## Calculate without dosing data {.build}

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
try({
  o_data <- PKNCAdata(o_conc)
  summary(pk.nca(o_data))
})
```

Whoops!  Without dosing, we need intervals.

## Calculate without dosing data, try 2

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
d_intervals <- data.frame(start=0, end=Inf, cmax=TRUE, tmax=TRUE,
                          half.life=TRUE, aucinf.obs=TRUE)
o_data_manual_intervals <- PKNCAdata(o_conc, intervals=d_intervals)
summary(pk.nca(o_data_manual_intervals))
```

## Dosing data helps with interval setup

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
o_dose <- PKNCAdose(Dose~dose_time|Treatment+Subject, data=d_dose)
o_data_auto_intervals <- PKNCAdata(o_conc, o_dose)
o_data_auto_intervals$intervals$aucint.inf.obs <- TRUE
summary(pk.nca(o_data_auto_intervals))
```

## AUC considerations with PKNCA (1/3) {.columns-2}

```{r auc-considerations-setup, warning=FALSE}
d_conc <-
  datasets::Theoph %>%
  filter(Subject == 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
d_interval_int <- data.frame(start=0, end=Inf, half.life=TRUE)
o_data_int <- PKNCAdata(o_conc, intervals=d_interval_int)
o_nca_int <- suppressMessages(pk.nca(o_data_int))
lambda_z_int <-
  o_nca_int %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "lambda.z") %>%
  "[["("PPORRES")

d_interval_inf <- data.frame(start=0, end=24, half.life=TRUE)
o_data_inf <- PKNCAdata(o_conc, intervals=d_interval_inf)
o_nca_inf <- suppressMessages(pk.nca(o_data_inf))
lambda_z_inf <-
  o_nca_inf %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "lambda.z") %>%
  "[["("PPORRES")

tlast <- 
  o_nca_inf %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "tlast") %>%
  "[["("PPORRES")

d_auc_calcs <-
  d_conc %>%
  bind_rows(
    tibble(Time=seq(12, 60))
  ) %>%
  mutate(
    conc_all_int=
      interp.extrap.conc(
        conc=conc[!is.na(conc)],
        time=Time[!is.na(conc)],
        time.out=Time,
        lambda.z=lambda_z_int
      ),
    conc_all_inf=
      interp.extrap.conc(
        conc=conc[!is.na(conc) & Time <= 24],
        time=Time[!is.na(conc) & Time <= 24],
        time.out=Time,
        lambda.z=lambda_z_inf
      ),
    conc_last=
      case_when(
        Time <= 24~conc,
        TRUE~NA_real_
      ),
    conc_int=
      case_when(
        Time <= 24 & Time >= tlast~conc_all_int,
        TRUE~NA_real_
      ),
    conc_inf=
      case_when(
        Time >= tlast~conc_all_inf,
        TRUE~NA_real_
      )
  ) %>%
  arrange(Time)
auc_figure_time_max <- 36
p_auc_calcs <-
  ggplot(d_auc_calcs, aes(x=Time, y=conc)) +
  # AUCinf (with a work-around for https://github.com/tidyverse/ggplot2/issues/4661)
  geom_area(
    data=d_auc_calcs %>% filter(Time <= auc_figure_time_max),
    aes(y=conc_inf, colour="AUCinf", fill="AUCinf"),
    alpha=0.2,
    na.rm=TRUE
  ) +
  geom_line(
    data=d_auc_calcs,
    aes(y=conc_inf, colour="AUCinf"),
    na.rm=TRUE
  ) +
  # AUCint
  geom_area(
    aes(y=conc_int, colour="AUCint", fill="AUCint"),
    alpha=0.2,
    na.rm=TRUE
  ) +
  # AUClast
  geom_area(
    aes(y=conc_last, colour="AUClast", fill="AUClast"),
    na.rm=TRUE
  ) +
  geom_point(show.legend=FALSE,
    na.rm=TRUE) +
  geom_line(show.legend=FALSE,
    na.rm=TRUE) +
  geom_vline(xintercept=24, linetype="63") +
  scale_x_continuous(breaks=seq(0, auc_figure_time_max, by=6)) +
  coord_cartesian(xlim=c(0, auc_figure_time_max)) +
  labs(
    colour="AUC type",
    fill="AUC type"
  )
```

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~last~** is calculated only based on points within the interval (the AUClast color in the figure)

## AUC considerations with PKNCA (2/3) {.columns-2}

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~int~** looks at the points in the interval, and if there is no measurement at the interval end time, interpolates or extrapolates to the interval end time (the AUClast and AUCint color in the figure)

## AUC considerations with PKNCA (3/3) {.columns-2}

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~&infin;~** is calculated based on AUC~last~, t~last~, and the half-life from t~last~, only using data within the interval-- no data after the end of the interval.
* Ensure that the interval used for calculating AUC~&infin;~ includes all the points desired (usually, `end=Inf`).

# Hands-on workshop

## Steady-state intramuscular administration

The data for the exercise are from a PK study of amikacin in a killer whale and a beluga whale.  (DOI: 10.1638/03-078)

![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)

(Callback...)

## Steady-state intramuscular administration

```{r eval=FALSE, echo=TRUE}
library(PKNCA)

d_conc <- read.csv("c:/tmp/whale_conc.csv")
d_dose <- read.csv("c:/tmp/whale_dose.csv")
head(d_conc)
head(d_dose)

o_conc <- PKNCAconc(concentration~time|Animal, data=d_conc)
o_dose <- PKNCAdose(dose~time|Animal, data=d_dose)
o_data <- PKNCAdata(o_conc, o_dose)
o_data$intervals
o_nca <- pk.nca(o_data)
summary(o_nca)
summary(o_nca, drop.group=c())
as.data.frame(o_nca)
```

# Day 2 Start

# Control your data

## Including and excluding data points

Data may be included/excluded in two ways:

* Overall: excluded a row of data from all analyses
* Half-life: excluded from half-life calculations, but included in all other analyses

For both ways of including/excluding data, it is defined by a column in the input data.  The column is either `NA` or an empty string (`""`) to indicate "no" or any other text to indicate "yes".

## Exclude data points overall {.columns-2}

Use the `exclude` argument for `PKNCAconc()` or `PKNCAdose()`.

When you use `exclude`, this is how you give your data to PKNCA:

```{r exclude-example-1, echo=TRUE}
d_before_exclude <-
 data.frame(
  time=0:4,
  conc=c(0, 2, 1, 0.5, 0.25),
  not_this=c(NA, "Not this", rep(NA, 3))
 )
o_conc <-
 PKNCAconc(
  data=d_before_exclude,
  conc~time,
  exclude="not_this"
 )
```

<p class="forceBreak"></p>

And, this is how PKNCA thinks about it:

```{r exclude-example-2, echo=TRUE}
pander::pander(
  d_before_exclude %>%
    filter(is.na(not_this))
)
```

## Exclude data points overall

```{r, echo=TRUE, eval=FALSE}
o_conc <- PKNCAconc(data=d_before_exclude, conc~time, exclude="not_this")
```

<div class="imessage">
<div class="yours messages">
  <div class="message last">Hey babe, did you get my 5 rows of data?</div>
</div>
<div class="mine messages">
  <div class="message last">I only saw 4 rows.  Are you sure you sent 5?</div>
</div>
<div class="yours messages">
  <div class="message last">Yep, definitely 5 check that last slide. &#128544;</div>
</div>
<div class="mine messages">
  <div class="message">...</div>
  <div class="message last">New phone.  Who dis?</div>
</div>
</div>

## Digression: How is &lambda;z automatically calculated? {.smaller}

* Filter the data from the first point after t~max~ (or from t~max~ if `allow.tmax.in.half.life=TRUE`) to t~last~ and excluding BLQ in the middle.
* Fit the semi-log line from 3 points before t~last~ (3 can be changed with the `min.hl.points` option) to t~last~.
    * Repeat for all sets of points from there to the first point included.
    * If that 3 points are not available, it is not calculated.
* Among the fits, select the best adjusted r^2^ (within a tolerance of `adj.r.squared.factor`).
* Require &lambda;z` > 0`.
* If more than one fit is available at this point, select the one with the most points included.

Note: WinNonlin first requires &lambda;z` > 0` then selects for adjusted r^2^.  Therefore, WinNonlin will occasionally provide a half-life when PKNCA will not, but the fit line is not as good (as measured by r^2^).  The selection of filtering order is an intentional feature with PKNCA, and it generally has minimal impact on summary statistics because the quality of the half-life fit is usually low in this scenario.

## &lambda;z control (manual exclusions and inclusions of data points)

Use the `exclude_half.life` or `include_half.life` argument for `PKNCAconc()`.  The two arguments behave very differently in how points are selected for half-life.

`exclude_half.life` uses the same automatic point selection method of curve stripping (described before), but it excludes individual points from that calculation.

`include_half.life` uses no automatic point selection method, and only points specifically noted by the analyst are included.

# Less-common calculations

## Urine calculations

```{r echo=TRUE}
d_urine <-
  data.frame(
    conc=c(1, 2, 3),
    urine_volume=c(200, 100, 300),
    time=c(1, 2, 3)
  )
o_conc <- PKNCAconc(data=d_urine, conc~time, volume="urine_volume")
d_intervals <- data.frame(start=0, end=24, ae=TRUE)
o_data <- PKNCAdata(o_conc, intervals=d_intervals)
o_nca <- suppressMessages(pk.nca(o_data))
summary(o_nca)
```

## Urine calculations: understanding what is happening and potential hiccups

Intervals for urine are treated the same as any other interval type.  Specifically, PKNCA does not look outside the start and end of the interval.

* Watch out for e.g. a 24-hour urine amount to be included in more than one interval because start = 0 and end = 24.
* Watch out for an actual start or end time to be outside of the interval and therefore to be omitted from calculations.

# Calculations below the hood

## PKNCA only calculates what is required, not every possible parameter (1 of 2)

If you don't need a parameter, PKNCA won't calculate it.

For example, if all you need is `cmax`, all you'll get is `cmax`.

```{r echo=TRUE}
o_conc <- PKNCAconc(data=data.frame(conc=2^-(1:4), time=0:3), conc~time)
o_data <- PKNCAdata(o_conc, intervals=data.frame(start=0, end=Inf, cmax=TRUE))
o_nca <- suppressMessages(pk.nca(o_data))
as.data.frame(o_nca)
```

## PKNCA only calculates what is required, not every possible parameter (2 of 2) {.columns-2 .smaller}

If you need AUC~0-\infty~, PKNCA will calculate other required parameters behind the scenes.

```{r echo=TRUE}
o_data <-
  PKNCAdata(
    o_conc,
    intervals=
      data.frame(
        start=0, end=Inf,
        aucinf.obs=TRUE
      )
  )
o_nca <- suppressMessages(pk.nca(o_data))
```

<p class="forceBreak"></p>

```{r echo=TRUE}
as.data.frame(o_nca)
```

## How to select the correct parameters for calculations (aka, why are there `r sum(grepl(x=names(PKNCA.options("single.dose.aucs")), pattern="^auc"))` types of AUC in PKNCA?)

CDISC has one set of names, but they are not precise (e.g. AUCINT doesn't tell the interpolation/extrapolation method).

PKNCA tries to be everything to everyone (in terms of parameters calculated), and it simultaneously tries to be precise.  That yields many parameters.

See the Selection of Calculation Intervals vignette in the [Parameters Available for Calculation in an Interval section](http://humanpred.github.io/pknca/articles/Selection-of-Calculation-Intervals.html#parameters-available-for-calculation-in-an-interval-1) for all available parameters.

## When are intervals (partly) ignored? {.smaller}

Very few parameters reach outside of the `start` and `end` of an interval for additional information about what is being calculated.  As of the writing of these training materials (PKNCA version 0.9.5), the only parameters that look outside are the `aucint` class of parameters.

AUC~int~ may look after the end of the interval to calculate the concentration at `end`.

Note: Watch out for a dose before the next concentration (e.g. a dose at 24 hours but the prior sample is around 12 and the next is around 25):

```{r fig.height=3}
d_prep <-
  datasets::Theoph %>%
  filter(Subject == 1) %>%
  mutate(
    conc=
      case_when(
        Time == 0~0,
        TRUE~conc
      )
  )
d_plot <-
  superposition(
    conc=d_prep$conc,
    time=d_prep$Time,
    tau=48,
    n.tau=1,
    dose.times=24*(0:1)
  ) %>%
  # Pretend that we missed the predose sample
  filter(
    !between(time, 23, 24.5)
  )
# Pretend that there was a dose at 24
ggplot(d_plot, aes(x=time, y=conc)) +
  geom_point() + geom_line() +
  geom_vline(xintercept=24) +
  scale_x_hours()
```

# Control your results

## Excluding results (Not the best way) {.smaller}

A simple way to exclude a value from results is to convert the results to a data.frame and then drop the rows you don't want:

```{r exclude-setup}
o_conc <- PKNCAconc(data=data.frame(conc=2^-(1:4), time=0:3), conc~time)
o_data <-
  PKNCAdata(
    o_conc,
    intervals=
      data.frame(
        start=0, end=Inf,
        aucinf.obs=TRUE
      )
  )
o_nca <- suppressMessages(pk.nca(o_data))
```

```{r exclude-not-best, echo=TRUE}
as.data.frame(o_nca) %>%
  filter(PPTESTCD != "half.life")
```

But, parameters derived from half-life remain.

## Excluding results (The best way, 1/2) {.columns-2 .smaller}

When you use the `exclude()` function, parameters that are dependent on an excluded parameter will be excluded.

```{r exclude-best, echo=TRUE}
o_nca_excluded <-
  o_nca %>%
  exclude(FUN=exclude_nca_span.ratio(3))
as.data.frame(o_nca_excluded)
```

## Excluding results (The best way, 2/2) {.smaller}

Now, everything dependent on the half-life is excluded in summaries.

```{r echo=TRUE}
summary(o_nca)
summary(o_nca_excluded)
```

# NCA-related calculations

## Superposition {.smaller .columns-2}

Superposition assumes linear kinetics and can convert a single-dose profile to multi-dose.

```{r echo=TRUE}
# Subject 2 is selected for a BLQ time=0 concentration
d_prep <-
  datasets::Theoph %>%
  filter(Subject == 2)
# Superposition to steady-state is the default
d_ss <-
  superposition(
    conc=d_prep$conc,
    time=d_prep$Time,
    tau=24
  )
# Going to steady-state is also an option
# (n.tau=2 means the second dose)
d_second_dose <-
  superposition(
    conc=d_prep$conc,
    time=d_prep$Time,
    tau=24,
    n.tau=2
  )
```

<p class="forceBreak"></p>

```{r echo=TRUE}
# Want the profile for the first two doses
# together?
d_first_two <-
  superposition(
    conc=d_prep$conc,
    time=d_prep$Time,
    tau=48, # 48 hours
    n.tau=1, # One tau interval (0 to 48 hours)
    dose.times=c(0, 24)
  )
```

```{r, fig.height=3, fig.width=3}
ggplot(d_ss, aes(x=time, y=conc)) +
  geom_point() + geom_line() +
  scale_y_continuous(limits=c(0, NA))
```

## Time-to-Steady-state calculations {.smaller}

Time-to-steady-state (tss) can be useful as a method to confirm that a subject is at steady-state.  PKNCA can calculate tss using trough concentrations either with a monoexponential increase toward steady-state (preferred) or a linear trend back from the final point.

```{r echo=TRUE}
dose_times <- seq(0, 96-1, by=6)
d_multidose <-
  superposition(
    conc=d_prep$conc,
    time=d_prep$Time,
    tau=96, # 48 hours
    n.tau=1, # One tau interval (0 to 48 hours)
    dose.times=dose_times
  )
pk.tss.monoexponential(
  conc=d_multidose$conc, time=d_multidose$time, subject=rep(1, nrow(d_multidose)),
  time.dosing=dose_times, subject.dosing=rep(1, length(dose_times)),
  output="single"
)
```

# Reporting

## Graphics are intentionally not part of PKNCA, but there are some tricks that can help...

Generate all individual profiles using the groups that you defined:

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Subject, data=datasets::Theoph)
d_plot <-
  grouped_df(data=datasets::Theoph, vars=names(getGroups(o_conc))) %>%
  nest() %>%
  mutate(
    figure=
      lapply(
        pmap(.l=list(data=data), .f=ggplot,aes(x=Time, y=conc)),
        FUN="+",
        geom_line()
      )
  )
# d_plot$figure
```

## Best practices for Data -> PKNCA -> knitr

Make summary tables using the `summary()` function on the NCA results, and use `pander::pander()` to make a pretty table with captions.

```{r echo=TRUE}
pander::pander(summary(o_nca))
```

Make an NCA data listing using the `as.data.frame()` function on the NCA results.

```{r echo=TRUE, eval=FALSE}
pander::pander(as.data.frame(o_nca))
```

## Units (especially clearance)

PKNCA supports units with the `pknca_units_table()` function.  See the
[Unit Assignment and Conversion with PKNCA](http://humanpred.github.io/pknca/articles/v07-unit-conversion.html)
vignette for more information.

When units are not specified, The most common place where that becomes an issue
is with clearance which ends up having unusual units like "mg/(hr*ng/mL)" (with
units of mg for dosing, hr for time, and ng/mL for concentration).

## Data imputation

Some data points are required for inputs such as:

* the start of the interval for AUC,
* the end of the interval for some calculations (e.g. AUC~last~ vs AUC~int~), and
* interpolated concentrations at the end of a urine interval for urinary PK calculations.

## IV bolus AUC (need to add C0)

Due to the need for back-extrapolation to C~0~, AUCs for IV bolus dosing need to
use different AUC parameters such as `"aucivlast"` instead of `"auclast"`.

## Combined, multi-subject data (e.g. sparse animal sampling)

Sparse NCA calculations are supported in PKNCA.  See the
[Sparse NCA Calculations](http://humanpred.github.io/pknca/articles/v04-sparse.html)
vignette for more information.

# Limitations

## Secondary parameters (e.g. bioavailability and renal clearance)

PKNCA does not (yet) have the ability to calculate secondary PK parameters that require looking at more than one group/interval at a time.

## Validation of PKNCA

PKNCA has an extensive testing and validation suite built-in.  To run the
testing and validation suite of tests with a full report generated, see the
[PKNCA Validation](http://humanpred.github.io/pknca/articles/v60-PKNCA-validation.html)
vignette.

# Hands-on

## Single- and Multiple-dose, single analyte: Setup the underlying datasets {.smaller}

```{r, echo=TRUE}
d_conc <-
  datasets::Theoph %>%
  rename(time=Time) %>%
  mutate(
    Subject=as.character(Subject)
  )
d_multidose <-
  PKNCAconc(conc~time|Subject, data=d_conc) %>%
  superposition(tau=24, check.blq=FALSE)
d_singledose_single_analyte <-
  d_conc %>%
  mutate(
    Study_Part="Single"
  )
d_multidose_single_analyte <-
  d_conc %>%
  mutate(Day=1) %>%
  bind_rows(
    d_multidose %>% mutate(time=time + 120, Day=6)
  ) %>%
  mutate(
    Study_Part="Multiple"
  )
```

## Single- and Multiple-dose, single analyte: Setup the concentration and dose datasets {.smaller}

```{r, echo=TRUE}
d_single_multi_conc <- bind_rows(d_singledose_single_analyte, d_multidose_single_analyte)
d_single_multi_dose <-
  d_single_multi_conc %>%
  filter(
    (Study_Part %in% "Single" & time == 0) |
      (Study_Part %in% "Multiple" & (time %% 24) == 0)
  )
```

## Single- and Multiple-dose, single analyte: Perform basic analysis {.smaller}

```{r, echo=TRUE}
o_conc <- PKNCAconc(data=d_single_multi_conc, conc~time|Study_Part+Subject)
o_dose <- PKNCAdose(data=d_single_multi_dose, Dose~time|Study_Part+Subject)
o_data <- PKNCAdata(o_conc, o_dose)
o_data$intervals %>% select(-Subject) %>% unique() %>% as.data.frame()
o_nca <- pk.nca(o_data)
```

## Single- and Multiple-dose, single analyte: Use intervals for fewer subjects {.smaller}

```{r echo=TRUE}
d_intervals <-
  data.frame(
    start=0,
    end=24,
    Subject=c("1", "2"),
    Study_Part="Single",
    aucinf.obs=TRUE
  )
o_data <- PKNCAdata(o_conc, o_dose, intervals=d_intervals)
o_nca <- pk.nca(o_data)
summary(o_nca)
```

## Single- and Multiple-dose, single analyte: Use custom intervals per subjects {.smaller}

```{r echo=TRUE}
# Find the time closest to 12 hours
d_intervals_prep <-
  d_single_multi_conc %>%
  filter(Study_Part == "Single") %>%
  mutate(
    time_deviation=abs(time-12)
  ) %>%
  group_by(Subject, Study_Part) %>%
  filter(time %in% time[time_deviation == min(time_deviation)])
d_intervals <-
  d_intervals_prep %>%
  select(Study_Part, Subject, end=time) %>%
  mutate(
    start=0,
    aucinf.obs=TRUE
  )
o_data <- PKNCAdata(o_conc, o_dose, intervals=d_intervals)

o_nca <- pk.nca(o_data)
summary(o_nca, drop.group=c("Subject", "end"))
```

## Single- and Multiple-dose, parent and metabolite

```{r, echo=TRUE}
d_single_multi_conc_multi_analyte <-
  bind_rows(
    d_single_multi_conc %>% mutate(Analyte="Parent"),
    d_single_multi_conc %>%
      mutate(
        Analyte="Metabolite",
        conc=conc/2
      )
  )
o_conc <-
  PKNCAconc(
    data=d_single_multi_conc_multi_analyte,
    conc~time|Study_Part+Subject/Analyte
  )
o_dose <- PKNCAdose(data=d_single_multi_dose, Dose~time|Study_Part+Subject)
o_data <- PKNCAdata(o_conc, o_dose)
o_nca <- pk.nca(o_data)
summary(o_nca)
```
